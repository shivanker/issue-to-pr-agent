
# aider chat started at 2025-04-07 15:44:53

> /tmp/aider-home/.local/bin/aider --no-gitignore --model gemini/gemini-2.5-pro-preview-03-25 --yes --auto-commits --dirty-commits --message-file /tmp/aider-message-1744040522680.txt  
> Aider v0.81.1  
> Main model: gemini/gemini-2.5-pro-preview-03-25 with diff-fenced edit format  
> Weak model: gemini/gemini-2.0-flash  
> Git repo: .git with 23 files  
> Repo-map: using 4096 tokens, auto refresh  
> https://aider.chat/HISTORY.html#release-notes  
> Would you like to see what's new in this version? (Y)es/(N)o [Yes]: y  

#### Issue #4: Extend app to handle PR comments  
####   
#### This is a simple GitHub app hosted on aws lambda. It listens for new issues on repos and tries to resolve the issue by proposing a PR. It does that by cloning the repo, and using a program called "aider" which uses AI-agents to modify the code. This is then  committed and pushed as a PR. Bulk of the aider related magic happens in change-implementer file.   
####   
#### I want to extend this app to also be able to reply to comments or change requests it receives on PRs produced by itself. It should modify the code according to the comments in the review, and update the PR on GitHub accordingly. Note that it may require aider to touch previously untouched files as well.  
####   
#### In the prompt to aider, I want to include all the comments along with the lines on which the comment was added.   
####   
#### Make sure to extract the code to run aider in a separate utils method / file that is used from change-implementer as well as the new code you're going to use for responding to comments. I want to reuse the way I invoke aider, with the file copying and streaming in the yeses and also the way it captures aider's stdio and posts comments in GitHub. Copying the files for aider to temp is only required once per lambda run though for setting up aider  
####   
####   
####   
####   
#### Please implement the necessary changes to address this issue. Focus on high quality implementation that follows best practices.  

Okay, I understand the request. To implement the functionality for handling PR comments and refactor the aider invocation logic, the following files are most likely to require changes:

1.  `src/webhook-service.ts`: To handle the new GitHub webhook event for PR comments (likely `pull_request_review_comment` or `issue_comment`).
2.  `src/change-implementer.ts`: To extract the existing aider logic and potentially adapt how changes are initiated based on comments.
3.  `src/git-service.ts`: To handle checking out the existing PR branch instead of creating a new one, and potentially incorporating comment details into the process.
4.  `src/github.ts`: To add functions for fetching PR review comments.
5.  `src/types.ts`: To add new type definitions for PR comment events, review comments, and potentially update related interfaces.

We will also need to create a new file, likely `src/aider-utils.ts`, to house the refactored aider execution logic.

Please add the following files to the chat so I can propose the necessary changes:

*   `src/webhook-service.ts`
*   `src/change-implementer.ts`
*   `src/git-service.ts`
*   `src/github.ts`
*   `src/types.ts`

> Tokens: 4.9k sent, 256 received. Cost: $0.0086 message, $0.0086 session.  
> src/change-implementer.ts  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> src/git-service.ts  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> src/github.ts  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> src/types.ts  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> src/webhook-service.ts  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  

Okay, I will start by refactoring the aider execution logic into a separate utility file (`src/aider-utils.ts`) and updating the existing `src/change-implementer.ts` to use it. This sets the stage for reusing the aider logic when handling PR comments.

**1. Create the Aider Utility File**

This new file will contain the core logic for setting up the aider environment and running the aider command, including streaming output and progress updates.

```
src/aider-utils.ts
<<<<<<< SEARCH
=======
import { config } from "./config";
import { exec, spawn } from "child_process";
import { IssueInfo, ChangeResult, RepoInfo } from "./types";
import { Octokit } from "@octokit/rest";
import { promisify } from "util";
import * as fs from "fs";
import * as os from "os";
import * as path from "path";
import { addIssueComment } from "./github"; // Assuming addIssueComment can also comment on PRs

const execPromise = promisify(exec);
const writeFilePromise = promisify(fs.writeFile);

let aiderEnvironmentSetupDone = false;

/**
 * Sets up the environment for running aider (e.g., copying binary).
 * Ensures this setup runs only once per Lambda invocation.
 */
function setupAiderEnvironment(): void {
  if (aiderEnvironmentSetupDone) {
    return;
  }
  console.log("Setting up aider environment...");
  // Copy the aider binary to the aiderHome directory if it doesn't exist
  if (!fs.existsSync(config.app.aiderHome)) {
    fs.mkdirSync(config.app.aiderHome, { recursive: true });
    // Ensure the source directory exists before copying
    const sourceDir = "/opt/bin"; // Source directory in Lambda environment
    if (fs.existsSync(sourceDir)) {
      fs.cpSync(sourceDir, config.app.aiderHome, { recursive: true });
      console.log(`Copied contents from ${sourceDir} to ${config.app.aiderHome}`);
    } else {
      console.warn(`Aider source directory ${sourceDir} not found. Skipping copy.`);
      // Optionally, try an alternative path if applicable
      // const altSourceDir = path.join(__dirname, '..', 'bin'); // Example alternative
      // if (fs.existsSync(altSourceDir)) {
      //   fs.cpSync(altSourceDir, config.app.aiderHome, { recursive: true });
      //   console.log(`Copied contents from ${altSourceDir} to ${config.app.aiderHome}`);
      // } else {
      //    console.error(`Aider binary source not found at ${sourceDir} or alternative paths.`);
      //    throw new Error("Aider binary source not found.");
      // }
    }
  } else {
    console.log(`Aider home directory ${config.app.aiderHome} already exists.`);
  }
  aiderEnvironmentSetupDone = true;
  console.log("Aider environment setup complete.");
}


/**
 * Executes a command with streaming I/O, progress updates, and error handling.
 * @param command The command to execute.
 * @param repoPath The path to the repository where the command should run.
 * @param repoInfo Repository information for posting updates.
 * @param issueInfo Issue information for posting updates.
 * @param octokit Authenticated Octokit instance.
 * @returns Promise resolving with stdout and stderr.
 */
const executeWithStreaming = (
  command: string,
  repoPath: string,
  repoInfo: RepoInfo,
  issueInfo: IssueInfo, // Using IssueInfo for PR number as well
  octokit: Octokit
): Promise<{ stdout: string; stderr: string }> => {
  return new Promise((resolve, reject) => {
    console.log(`Executing command in ${repoPath}: ${command}`);
    const proc = spawn(command, {
      shell: true,
      cwd: repoPath,
      stdio: ["pipe", "pipe", "pipe"], // stdin, stdout, stderr
      env: {
        ...process.env,
        HOME: config.app.aiderHome, // Ensure HOME is set for aider config/cache
        PATH: `${config.app.aiderHome}/.local/bin:${process.env.PATH}`, // Ensure aider is in PATH
      },
    });

    let stdoutData = "";
    let stderrData = "";
    let lastLogTime = Date.now();
    const LOG_INTERVAL = 45000; // 45 seconds

    // Provide automatic 'y' responses to any prompts
    let autoResponder: NodeJS.Timeout | null = null;
    if (proc.stdin) {
      // Write 'y' + enter periodically to answer any prompts that might appear
      autoResponder = setInterval(() => {
        if (!proc.stdin?.writableEnded) {
          proc.stdin.write("y\n", (err) => {
             if (err) console.error("Error writing 'y' to stdin:", err);
          });
        } else {
           if (autoResponder) clearInterval(autoResponder);
        }
      }, 5000); // Respond every 5 seconds

      // Clean up interval when process ends
      const cleanupAutoResponder = () => {
        if (autoResponder) clearInterval(autoResponder);
        if (!proc.stdin?.writableEnded) {
           proc.stdin.end(); // Close stdin when process finishes
        }
      };
      proc.on("close", cleanupAutoResponder);
      proc.on("error", cleanupAutoResponder);
    }


    // Function to post a combined update to the issue/PR
    const postCombinedUpdate = async () => {
      if (Date.now() - lastLogTime > LOG_INTERVAL) {
        try {
          const hasStdout = stdoutData.trim().length > 0;
          const hasStderr = stderrData.trim().length > 0;

          // Only post if there's new significant output
          if (!hasStdout && !hasStderr) {
             lastLogTime = Date.now(); // Reset timer even if nothing to post
             return;
          }

          let commentBody = `🔄 **AI Agent Progress Update (Issue/PR #${issueInfo.number})**\n\n`;
          const maxSnippetLength = 300; // Max length for recent output snippets

          // Add stdout section if there's output
          if (hasStdout) {
            const stdoutSnippet = stdoutData.substring(Math.max(0, stdoutData.length - maxSnippetLength)).trim();
            commentBody +=
              `<details>\n` +
              `<summary>Standard Output Log (click to expand)</summary>\n\n` +
              `\`\`\`\n${stdoutData}\n\`\`\`\n` +
              `</details>\n\n` +
              `**Recent output:**\n\`\`\`\n${stdoutSnippet}\n\`\`\`\n\n`;
          }

          // Add stderr section if there's output
          if (hasStderr) {
             const stderrSnippet = stderrData.substring(Math.max(0, stderrData.length - maxSnippetLength)).trim();
            commentBody +=
              `<details>\n` +
              `<summary>⚠️ Error Output Log (click to expand)</summary>\n\n` +
              `\`\`\`\n${stderrData}\n\`\`\`\n` +
              `</details>\n\n` +
              `**Recent error output:**\n\`\`\`\n${stderrSnippet}\n\`\`\`\n\n`;
          }

          await addIssueComment(
            octokit,
            repoInfo.owner,
            repoInfo.repo,
            issueInfo.number, // Post to the issue/PR number
            commentBody
          );
          console.log(`Posted combined progress update to issue/PR #${issueInfo.number}`);
          // Clear buffers after posting to avoid reposting same content? No, keep full log.
        } catch (error) {
          console.error(
            `Failed to post combined progress comment to issue/PR #${issueInfo.number}:`,
            error
          );
        }
        lastLogTime = Date.now(); // Reset timer after attempting post
      }
    };

    proc.stdout?.on("data", async (data) => {
      const chunk = data.toString();
      stdoutData += chunk;
      // Log only a snippet to avoid excessive logging
      console.log("Command stdout (snippet):", chunk.substring(0, 200).replace(/\n/g, ' '));
      await postCombinedUpdate();
    });

    proc.stderr?.on("data", async (data) => {
      const chunk = data.toString();
      stderrData += chunk;
      console.error("Command stderr (snippet):", chunk.substring(0, 200).replace(/\n/g, ' '));
      await postCombinedUpdate();
    });

    proc.on("close", (code) => {
      console.log(`Command exited with code ${code}`);
      // Attempt one final update post before resolving/rejecting
      postCombinedUpdate().finally(() => {
          if (code !== 0) {
            const error = new Error(`Command exited with code ${code}`);
            (error as any).stdout = stdoutData;
            (error as any).stderr = stderrData;
            reject(error);
          } else {
            resolve({ stdout: stdoutData, stderr: stderrData });
          }
      });
    });

    proc.on("error", (error) => {
      console.error("Command execution error:", error);
       // Attempt one final update post before rejecting
       postCombinedUpdate().finally(() => {
          (error as any).stdout = stdoutData;
          (error as any).stderr = stderrData;
          reject(error);
       });
    });
  });
};


/**
 * Runs the aider tool to implement changes based on a message.
 *
 * @param repoPath Path to the cloned repository.
 * @param message The instruction message for aider.
 * @param repoInfo Information about the repository.
 * @param issueInfo Information about the issue (used for context and commenting).
 * @param octokit Authenticated Octokit instance.
 * @returns Promise resolving with the list of changed files and command output.
 */
export async function runAider(
  repoPath: string,
  message: string,
  repoInfo: RepoInfo,
  issueInfo: IssueInfo, // Can represent an issue or a PR
  octokit: Octokit
): Promise<ChangeResult> {
  console.log(`Running aider for issue/PR #${issueInfo.number} in ${repoPath}`);

  // Ensure aider environment is set up (idempotent)
  setupAiderEnvironment();

  let commandOutput = { stdout: "", stderr: "" };
  const changedFiles: string[] = [];

  // Get initial git status to compare later
  const { stdout: initialGitStatus } = await execPromise(
    `cd "${repoPath}" && git status --porcelain`
  ).catch(err => {
      console.warn("Could not get initial git status:", err);
      return { stdout: "" }; // Proceed even if status fails initially
  });
  const initialFiles = new Set(
    initialGitStatus
      .split("\n")
      .filter((line) => line.trim() !== "")
      .map((line) => {
        const match = line.match(/^..\s+(.+)$/);
        return match ? match[1].trim() : null; // Trim filename
      })
      .filter((filename): filename is string => filename !== null)
  );
  console.log("Initial tracked files:", Array.from(initialFiles));


  // Create a temporary file for the message
  const tempMessageDir = path.join(os.tmpdir(), 'aider-messages');
  if (!fs.existsSync(tempMessageDir)) {
      fs.mkdirSync(tempMessageDir, { recursive: true });
  }
  const tempFilePath = path.join(
    tempMessageDir,
    `aider-message-${repoInfo.owner}-${repoInfo.repo}-${issueInfo.number}-${Date.now()}.txt`
  );

  try {
    // Write the message to the temporary file
    await writeFilePromise(tempFilePath, message);
    console.log(`Aider message written to temporary file: ${tempFilePath}`);

    // Construct the aider command
    // Using --yes for auto-acceptance, --auto-commits for automatic commits by aider
    // --dirty-commits allows committing even if the repo isn't clean (aider handles staging)
    // --no-gitignore to ensure aider can see all files if needed
    // --model specifies the AI model
    const aiderCommand = `${config.app.aiderHome}/.local/bin/aider --model ${config.app.aiderModel} --yes --auto-commits --dirty-commits --no-gitignore --message-file "${tempFilePath}"`;

    console.log(`Running aider command: ${aiderCommand}`);

    // Execute aider using the streaming function
    const { stdout, stderr } = await executeWithStreaming(
        aiderCommand,
        repoPath,
        repoInfo,
        issueInfo,
        octokit
    );
    commandOutput = { stdout, stderr };

    console.log("Aider command finished.");
    // console.log("Aider stdout:", stdout); // Often very long, log snippet or rely on progress updates
    // console.log("Aider stderr:", stderr);

  } catch (error) {
    console.error("Error running aider command:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    // Capture output even if the command fails
    if (error && typeof error === 'object') {
        commandOutput.stdout = (error as any).stdout || commandOutput.stdout || "";
        commandOutput.stderr = (error as any).stderr || commandOutput.stderr || "";
    }
    commandOutput.stderr += `\n\nError during aider execution: ${errorMessage}`;

    // Re-throw the error after capturing output, ensuring it includes the output
    const enhancedError = new Error(
      `Failed to run aider command: ${errorMessage}`,
      { cause: error }
    );
    (enhancedError as any).output = commandOutput;
    throw enhancedError;

  } finally {
     // Clean up the temporary message file
     if (fs.existsSync(tempFilePath)) {
       try {
         fs.unlinkSync(tempFilePath);
         console.log(`Cleaned up temporary message file: ${tempFilePath}`);
       } catch (unlinkError) {
         console.error(`Error cleaning up temporary message file ${tempFilePath}:`, unlinkError);
       }
     }
  }

  // --- Detect changed files ---
  try {
    console.log("Detecting changed files after aider execution...");
    // Strategy 1: Check git status for uncommitted changes (aider might not always commit)
    const { stdout: gitStatusOutput } = await execPromise(
      `cd "${repoPath}" && git status --porcelain`
    );
    const currentFiles = new Set(
      gitStatusOutput
        .split("\n")
        .filter((line) => line.trim() !== "")
        .map((line) => {
          const match = line.match(/^..\s+(.+)$/);
          return match ? match[1].trim() : null; // Trim filename
        })
        .filter((filename): filename is string => filename !== null)
    );
     console.log("Files in git status after aider:", Array.from(currentFiles));


    // Files changed according to git status (new, modified, deleted compared to initial state)
    const statusChangedFiles = new Set<string>();
    for (const file of currentFiles) {
        if (!initialFiles.has(file)) { // New or modified file detected by status
            statusChangedFiles.add(file);
        }
    }
    for (const file of initialFiles) {
        if (!currentFiles.has(file)) { // Deleted file detected by status
            statusChangedFiles.add(file);
        }
    }
     console.log("Files changed based on git status diff:", Array.from(statusChangedFiles));


    // Strategy 2: Check files changed in the last commit (if aider used --auto-commits)
    let commitChangedFiles = new Set<string>();
    try {
      // Get files from the most recent commit on the current branch
      const { stdout: lastCommitFilesOutput } = await execPromise(
        `cd "${repoPath}" && git show --name-only --pretty="" HEAD`
      );
      commitChangedFiles = new Set(
        lastCommitFilesOutput
          .split("\n")
          .filter((line) => line.trim() !== "")
          .map(file => file.trim()) // Trim filenames
      );
      console.log("Files changed in last commit (HEAD):", Array.from(commitChangedFiles));
    } catch (error) {
      console.warn("Could not get files from last commit (maybe no commits yet or other git issue):", error);
      // If this fails, rely solely on git status changes
    }

    // Combine results: Files detected by status + files detected in last commit
    const combinedChangedFiles = new Set([...statusChangedFiles, ...commitChangedFiles]);

    // Convert Set to Array for the final result
    changedFiles.push(...combinedChangedFiles);

    console.log(`Detected ${changedFiles.length} changed files:`, changedFiles);

    // Return the result including the command output
    return { changedFiles, output: commandOutput };

  } catch (error) {
    console.error("Error detecting changed files:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    commandOutput.stderr += `\n\nError detecting changed files: ${errorMessage}`;

    // Re-throw with the updated command output
    const enhancedError = new Error(
      `Failed to detect changed files: ${errorMessage}`,
      { cause: error }
    );
    (enhancedError as any).output = commandOutput;
    throw enhancedError;
  }
}
>>>>>>> REPLACE
```

**2. Refactor `src/change-implementer.ts`**

Update this file to import and use the `runAider` function from the new utility file.

```
src/change-implementer.ts
<<<<<<< SEARCH
import { addIssueComment } from "./github";
import { config } from "./config";
import { exec, spawn } from "child_process";
import { IssueInfo, ChangeResult, RepoInfo } from "./types";
import { Octokit } from "@octokit/rest";
import { promisify } from "util";
import * as fs from "fs";
import * as os from "os";
import * as path from "path";

const execPromise = promisify(exec);
const writeFilePromise = promisify(fs.writeFile);
=======
import { config } from "./config";
import { IssueInfo, ChangeResult, RepoInfo } from "./types";
import { Octokit } from "@octokit/rest";
import { runAider } from "./aider-utils"; // Import the refactored function
>>>>>>> REPLACE
```

```
src/change-implementer.ts
<<<<<<< SEARCH
  console.log(
    `Implementing changes for issue #${issueInfo.number} in ${repoPath}`
  );

  const changedFiles: string[] = [];
  let commandOutput = { stdout: "", stderr: "" };

  // Get initial git status to compare later
  const { stdout: initialGitStatus } = await execPromise(
    `cd "${repoPath}" && git status --porcelain`
  );
  const initialFiles = new Set(
    initialGitStatus
      .split("\n")
      .filter((line) => line.trim() !== "")
      .map((line) => {
        const match = line.match(/^..\s+(.+)$/);
        return match ? match[1] : null;
      })
      .filter((filename) => filename !== null) as string[]
  );
=======
  console.log(
    `Preparing instructions for aider for issue #${issueInfo.number} in ${repoPath}`
  );

  // Ensure octokit is provided if needed by runAider for progress updates
  if (!octokit) {
    throw new Error("Octokit instance is required for defaultChangeImplementer");
  }
  if (!repoInfo) {
      throw new Error("RepoInfo is required for defaultChangeImplementer");
  }
>>>>>>> REPLACE
```

```
src/change-implementer.ts
<<<<<<< SEARCH
  // Create a temporary file for the message
  const tempFilePath = path.join(
    os.tmpdir(),
    `aider-message-${Date.now()}.txt`
  );

  try {
    // Write the message to the temporary file
    await writeFilePromise(tempFilePath, structuredMessage);
    console.log(`Message written to temporary file: ${tempFilePath}`);

    // Copy the aider binary to the aiderHome directory
    if (!fs.existsSync(config.app.aiderHome)) {
      fs.mkdirSync(config.app.aiderHome, { recursive: true });
      fs.cpSync("/opt/bin", config.app.aiderHome, { recursive: true });
    }

    // Run aider command to implement changes with message-file
    const aiderCommand = `${config.app.aiderHome}/.local/bin/aider --no-gitignore --model gemini/gemini-2.5-pro-preview-03-25 --yes --auto-commits --dirty-commits --message-file "${tempFilePath}"`;

    console.log(`Running aider command: ${aiderCommand}`);

    const executeWithStreaming = (
      command: string
    ): Promise<{ stdout: string; stderr: string }> => {
      return new Promise((resolve, reject) => {
        const proc = spawn(command, {
          shell: true,
          cwd: repoPath,
          stdio: ["pipe", "pipe", "pipe"], // stdin, stdout, stderr
          env: {
            ...process.env,
            HOME: config.app.aiderHome,
            PATH: `${config.app.aiderHome}/.local/bin:${process.env.PATH}`,
          },
        });

        // Provide automatic 'y' responses to any prompts
        if (proc.stdin) {
          // Write 'y' + enter periodically to answer any prompts that might appear
          const autoResponder = setInterval(() => {
            proc.stdin?.write("y\n");
          }, 5000); // Check every 5 seconds

          // Clean up interval when process ends
          proc.on("close", () => clearInterval(autoResponder));
          proc.on("error", () => clearInterval(autoResponder));
        }

        let stdoutData = "";
        let stderrData = "";
        let lastLogTime = Date.now();
        const LOG_INTERVAL = 45000;

        // Function to post a combined update to the issue
        const postCombinedUpdate = async () => {
          if (
            Date.now() - lastLogTime > LOG_INTERVAL &&
            octokit &&
            repoInfo &&
            issueInfo
          ) {
            try {
              const hasStdout = stdoutData.trim().length > 0;
              const hasStderr = stderrData.trim().length > 0;

              let commentBody = `🔄 **Progress Update for Issue #${issueInfo.number}**\n\n`;

              // Add stdout section if there's output
              if (hasStdout) {
                commentBody +=
                  `<details>\n` +
                  `<summary>Standard Output (click to expand full log)</summary>\n\n` +
                  `\`\`\`\n${stdoutData}\n\`\`\`\n` +
                  `</details>\n\n` +
                  `**Recent output:** \`${stdoutData.substring(
                    Math.max(0, stdoutData.length - 200)
                  )}\`\n\n`;
              }

              // Add stderr section if there's output
              if (hasStderr) {
                commentBody +=
                  `<details>\n` +
                  `<summary>⚠️ Error Output (click to expand full log)</summary>\n\n` +
                  `\`\`\`\n${stderrData}\n\`\`\`\n` +
                  `</details>\n\n` +
                  `**Recent error output:** \`${stderrData.substring(
                    Math.max(0, stderrData.length - 200)
                  )}\`\n\n`;
              }

              await addIssueComment(
                octokit,
                repoInfo.owner,
                repoInfo.repo,
                issueInfo.number,
                commentBody
              );
              console.log("Posted combined progress update to issue");
            } catch (error) {
              console.error(
                "Failed to post combined progress comment to issue:",
                error
              );
            }
            lastLogTime = Date.now();
          }
        };

        proc.stdout.on("data", async (data) => {
          const chunk = data.toString();
          stdoutData += chunk;
          console.log("Command output:", chunk.substring(chunk.length - 200));
          await postCombinedUpdate();
        });

        proc.stderr.on("data", async (data) => {
          const chunk = data.toString();
          stderrData += chunk;
          console.error(
            "Command error output:",
            chunk.substring(chunk.length - 200)
          );
          await postCombinedUpdate();
        });

        proc.on("close", (code) => {
          if (code !== 0) {
            const error = new Error(`Command exited with code ${code}`);
            (error as any).stdout = stdoutData;
            (error as any).stderr = stderrData;
            reject(error);
          } else {
            resolve({ stdout: stdoutData, stderr: stderrData });
          }
        });

        proc.on("error", (error) => {
          (error as any).stdout = stdoutData;
          (error as any).stderr = stderrData;
          reject(error);
        });
      });
    };

    // For the long-running aiderCommand, use the streaming version
    const { stdout, stderr } = await executeWithStreaming(aiderCommand);
    commandOutput = { stdout, stderr };

    console.log("Aider command stdout:", stdout);
    console.log("Aider command stderr:", stderr);
  } catch (error) {
    // Capture any error from the aider command, but still try to collect changed files
    // and include the error in the result's output
    console.error("Error running aider command:", error);

    // Add error to stderr output
    const errorMessage = error instanceof Error ? error.message : String(error);
    commandOutput.stderr += `\n\nError running aider command: ${errorMessage}`;

    // Re-throw the error after we've updated the commandOutput
    const enhancedError = new Error(
      `Failed to run aider command: ${errorMessage}`,
      { cause: error }
    );
    (enhancedError as any).output = commandOutput;
    throw enhancedError;
  }

  try {
    // Get list of changed files by checking git status
    // This will include both staged and unstaged changes
    const { stdout: gitStatusOutput } = await execPromise(
      `cd "${repoPath}" && git status --porcelain`
    );

    // Parse git status output to get changed files
    const currentFiles = new Set(
      gitStatusOutput
        .split("\n")
        .filter((line) => line.trim() !== "")
        .map((line) => {
          // Git status --porcelain format is "XY filename"
          // where X is status in staging area, Y is status in working directory
          const match = line.match(/^..\s+(.+)$/);
          return match ? match[1] : null;
        })
        .filter((filename) => filename !== null) as string[]
    );

    // Find new files that weren't in the initial status
    for (const file of currentFiles) {
      if (!initialFiles.has(file)) {
        changedFiles.push(file);
      }
    }

    // Also find files that were in initial status but no longer in current status (deleted files)
    for (const file of initialFiles) {
      if (!currentFiles.has(file)) {
        changedFiles.push(file);
      }
    }

    // If aider made commits already, we need to detect what files were changed in those commits
    // This gets the list of files changed in the most recent commit
    try {
      const { stdout: lastCommitFiles } = await execPromise(
        `cd "${repoPath}" && git show --name-only --pretty="" HEAD`
      );
      const commitChangedFiles = lastCommitFiles
        .split("\n")
        .filter((line) => line.trim() !== "");

      // Add files from the commit that aren't already in our list
      for (const file of commitChangedFiles) {
        if (!changedFiles.includes(file)) {
          changedFiles.push(file);
        }
      }
    } catch (error) {
      // If this fails, it might be because there are no commits yet, which is fine
      console.log("Could not get files from last commit, continuing...");
    }

    console.log(`Modified ${changedFiles.length} files`);

    return { changedFiles, output: commandOutput };
  } catch (error) {
    console.error("Error detecting changed files:", error);

    // Add error to stderr output
    const errorMessage = error instanceof Error ? error.message : String(error);
    commandOutput.stderr += `\n\nError detecting changed files: ${errorMessage}`;

    // Re-throw with the updated command output
    const enhancedError = new Error(
      `Failed to detect changed files: ${errorMessage}`,
      {
        cause: error,
      }
    );
    (enhancedError as any).output = commandOutput;
    throw enhancedError;
  }
=======
  // Call the refactored runAider function
  const result = await runAider(
    repoPath,
    structuredMessage,
    repoInfo,
    issueInfo,
    octokit
  );

  console.log(
    `Aider finished for issue #${issueInfo.number}. Changed files: ${result.changedFiles.join(", ")}`
  );

  return result;
>>>>>>> REPLACE
```

These changes create the `src/aider-utils.ts` file with the core aider execution logic and update `src/change-implementer.ts` to use this new utility. The next steps will involve modifying the webhook service, git service, GitHub utilities, and types to handle PR comments.

> Tokens: 9.9k sent, 6.2k received. Cost: $0.07 message, $0.08 session.  
> src/aider-utils.ts  
> Create new file? (Y)es/(N)o [Yes]: y  
> Applied edit to src/aider-utils.ts  
> Applied edit to src/change-implementer.ts  
> Commit 91a8281 Refactor: Extract aider execution logic to aider-utils.ts  
